# SlotMathModule

Модуль математики слотовых игр, вынесенный из проектов R-Gamble и UnityMultiGame.

## Структура

### SuperBall/
Математика игры SuperBall из LocalServer/MathematicModule/Superball/
- **SuperballMath.cs** - основная математика SuperBall с генерацией ленты выигрышей

### GameLogic/
Математика слотовых игр из UnityMultiGame/GameLogic/

#### Core/
- **Game.cs** - абстрактный базовый класс игры
- **Slot.cs** - базовый класс слота
- **Map.cs** - матрица игры и расчет выигрышей
- **Feed.cs** - генерация ленты выигрышей
- **Line.cs** - проверка выигрышных линий
- **WinLine.cs** - выигрышная линия
- **Symbol.cs** - символ игры
- **FeedStatistic.cs** - статистика ленты
- **FeedFake.cs** - тестовые режимы ленты
- **ConstraintFilter.cs** - фильтр ограничений
- **Play.cs** - класс для тестирования

#### Games/
- **Slot5_3.cs** - базовая слотовая игра 5x3
- **SuperBall.cs** - логика SuperBall для Unity
- **HappySeven.cs** - логика HappySeven
- **GameIdentity.cs** - атрибут для идентификации игр

### Common/
Общие модели и параметры

#### Models/
- **GamePropertiesModel.cs** - параметры игры
- **TiketGameModel.cs** - модель результата игры
- **WriteLogDelegate.cs** - делегат для логирования

- **GameParams.cs** - дополнительные параметры игры

## Использование

Модуль можно подключать к серверу или в билд как отдельную библиотеку.

## Namespace

Все классы находятся в namespace `SlotMathModule`:
- `SlotMathModule.GameLogic.Core` - основные классы
- `SlotMathModule.GameLogic.Games` - конкретные игры
- `SlotMathModule.SuperBall` - математика SuperBall
- `SlotMathModule.Common` - общие модели

## Зависимости

- .NET Framework 2.0+
- Newtonsoft.Json (для SuperBall)

Как работает текущая математика
1. Система символов
Математика работает с символами (Symbol), которые абстрактны. Каждый символ имеет:
Name — название (например, "красная машина", "джип")
Index — числовой идентификатор
Wins[] — массив выигрышей для разных количеств совпадений (3, 4, 5 символов)
Пример: можно создать символы:
Индекс 1: "Красная легковая" — выигрыши [0, 0, 10, 50, 200]
Индекс 2: "Синяя легковая" — выигрыши [0, 0, 15, 60, 250]
Индекс 3: "Красный джип" — выигрыши [0, 0, 20, 80, 300]
Индекс 4: "Синий джип" — выигрыши [0, 0, 25, 100, 400]
2. Логика Wild Cards
Wild уже реализован. Как это работает:
// В Game есть свойство:public int Wild; // индекс wild-символа// Wild может заменять ЛЮБОЙ другой символ в выигрышной линии// Например, если у вас линия: [Красная машина] [Wild] [Красная машина] [Красная машина]// Это считается как 4 красные машины подряд!
Особенности:
Wild заменяет любой символ в линии
Wild может быть на любой позиции (есть настройка WildOnFirstReel)
Можно использовать несколько wild-символов (AddWild)
Wild не заменяет Scatter (бонусные символы)
3. Адаптация под твою концепцию
Вариант 1: Цвета как отдельные символы
Символ 1: Красная легковая (маленькая)Символ 2: Синяя легковая (маленькая)Символ 3: Красный джип (большая)Символ 4: Синий джип (большая)Символ 5: Wild (любая машина)
Вариант 2: Комбинированная логика
Можно сделать так, чтобы выигрывали:
По цвету: 3+ красные машины (любого типа)
По типу: 3+ джипы (любого цвета)
Комбо: 3+ красных джипа = максимальный выигрыш
Для этого нужно:
Создать кастомную логику проверки выигрышных линий
Переопределить метод CheckSymbolInWinline в твоей игре
Или создать отдельные символы для каждого сочетания
4. Структура матрицы
Текущая математика поддерживает матрицы 5x3 (15 ячеек), но можно настроить:
MapSize — размер матрицы
MaxLine — количество линий
lines — определение выигрышных линий
Для 5 полос движения это подходит: каждая полоса = колонка, 3 ряда = позиции машин.
5. Рекомендации для твоей игры
Создай класс игры, наследующий Game:
public class TrafficSlot : Game{    // Определи символы    protected override void CreateSymbol()    {        AddSymbol(new Symbol("Красная легковая", new int[] {0, 0, 10, 50, 200}));        AddSymbol(new Symbol("Синяя легковая", new int[] {0, 0, 15, 60, 250}));        AddSymbol(new Symbol("Красный джип", new int[] {0, 0, 20, 80, 300}));        AddSymbol(new Symbol("Синий джип", new int[] {0, 0, 25, 100, 400}));        AddSymbol(new Symbol("Wild", new int[] {0, 0, 0, 0, 0})); // Wild не дает выигрыш сам по себе        AddSymbol(new Symbol("Scatter", new int[] {0, 0, 0, 0, 0})); // Для бонусов    }        // Определи линии (5 полос = 5 колонок)    protected override void CreateLines()    {        // Горизонтальные линии        AddLine(new Line(new int[] {0, 1, 2, 3, 4})); // Верхняя        AddLine(new Line(new int[] {5, 6, 7, 8, 9})); // Средняя        AddLine(new Line(new int[] {10, 11, 12, 13, 14})); // Нижняя    }}
Логика светофора:
Можно сделать так, чтобы при красном свете машины останавливались на определенных позициях
Это можно реализовать через FillMapSequence или кастомную логику в GetMapByFeedItem
Комбинации по цвету/типу:
Переопредели CheckSymbolInWinline, чтобы проверять не только точное совпадение, но и цвет/тип
